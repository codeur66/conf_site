from django.contrib.auth.models import User
from django.core.mail import send_mass_mail
from django.db import models
from django.template import Context, Template

from symposion.markdown_parser import parse


class ProposalVote(models.Model):
    """
    Model to track votes made on a proposal.

    This model replaces symposion.reviews.models.Comment,
    symposion.reviews.models.Review, and symposion.reviews.models.LatestVote.

    Fields:
    proposal - The proposal associated with this vote.
    voter - The user that made the vote.
    score - The user's vote, represented as two characters.
    comment - The Markdown-formatted text of the vote's comment (optional).
    comment_html - An autogenerated HTML version of the vote's comment.
    date_created - The date/time that the vote was created.
    date_modified - The date/time that the vote was last modified.
    """

    # These values are based on the historical ones found in
    # symposion.reviews.models.score_expression().
    # This allows us to use integers directly which makes
    # calculating scores easier.
    PLUS_ONE = 3
    PLUS_ZERO = 1
    TRUE_ZERO = 0
    MINUS_ZERO = -1
    MINUS_ONE = -3
    SCORES = [
        (
            PLUS_ONE,
            "+1 — Good proposal and I will argue for it to be accepted.",
        ),
        (
            PLUS_ZERO,
            "+0 — OK proposal, but I will not argue for it to be accepted.",
        ),
        (
            MINUS_ZERO,
            "−0 — Weak proposal, but I will not argue against acceptance.",
        ),
        (
            MINUS_ONE,
            "−1 — Serious issues and I will argue to reject this proposal.",
        ),
        (
            TRUE_ZERO,
            "A — I abstain from voting on this proposal.",
        ),
    ]

    proposal = models.ForeignKey(
        "proposals.Proposal",
        on_delete=models.CASCADE,
        related_name="review_votes",
    )
    voter = models.ForeignKey(
        User, on_delete=models.CASCADE, related_name="review_votes"
    )
    score = models.SmallIntegerField(blank=True, null=True, choices=SCORES)
    comment = models.TextField(blank=True)
    comment_html = models.TextField(blank=True, editable=False)
    date_created = models.DateTimeField(auto_now_add=True)
    date_modified = models.DateTimeField(auto_now=True)

    def save(self, *args, **kwargs):
        self.comment_html = parse(self.comment)
        return super(ProposalVote, self).save(*args, **kwargs)

    def get_numeric_score_display(self):
        """Returns numeric value at beginning of score display string."""
        if self.score is None:
            return "R"
        return self.get_score_display()[0:2].strip()


def proposalvote_score_cache_key(proposal, voter):
    """
    Return the cache key for a ProposalVote's score
    based on the proposal and voting user.
    """
    return "proposalvote_{}_{}_score".format(proposal.pk, voter.pk)


class ProposalFeedback(models.Model):
    proposal = models.ForeignKey(
        "proposals.Proposal",
        on_delete=models.CASCADE,
        related_name="review_feedback",
    )
    author = models.ForeignKey(
        User, on_delete=models.CASCADE, related_name="review_feedback"
    )
    comment = models.TextField(blank=True)
    comment_html = models.TextField(blank=True, editable=False)
    date_created = models.DateTimeField(auto_now_add=True)
    date_modified = models.DateTimeField(auto_now=True)

    def save(self, *args, **kwargs):
        self.comment_html = parse(self.comment)
        return super(ProposalFeedback, self).save(*args, **kwargs)


class ProposalResult(models.Model):
    """
    Model to track whether a proposal's acceptance and notification status.

    This model replaces symposion.reviews.models.ProposalResult and
    symposion.reviews.models.ResultNotification.
    """

    RESULT_ACCEPTED = "A"
    RESULT_REJECTED = "R"
    RESULT_STANDBY = "S"
    RESULT_UNDECIDED = "U"

    RESULT_STATUSES = [
        (RESULT_UNDECIDED, "Undecided"),
        (RESULT_ACCEPTED, "Accepted"),
        (RESULT_REJECTED, "Rejected"),
        (RESULT_STANDBY, "Standby"),
    ]

    proposal = models.OneToOneField(
        "proposals.Proposal",
        on_delete=models.CASCADE,
        related_name="review_result",
    )
    status = models.CharField(
        choices=RESULT_STATUSES, default=RESULT_UNDECIDED, max_length=1
    )


class ProposalNotification(models.Model):
    """Model to track notifications sent to proposal speakers."""

    from_address = models.EmailField()
    subject = models.CharField(max_length=254)
    body = models.TextField()
    proposals = models.ManyToManyField(
        "proposals.Proposal",
        blank=True,
        related_name="review_notifications",
    )
    date_sent = models.DateTimeField(
        verbose_name="Date this notification was created and sent",
        auto_now_add=True,
    )

    def __str__(self):
        return "{}".format(self.subject)

    def send_email(self):
        """Returns a list of speakers without email addresses."""
        email_messages = []
        unemailed = []
        # Create a message for each email address.
        # This is necessary because we are not using BCC.
        for proposal in self.proposals.all():
            # In order to support the "variable substitution"
            # supported by the previous reviews system, the
            # message needs to be templated anew for each
            # proposal.
            message_body = Template(self.body).render(
                Context({"proposal": proposal.notification_email_context()})
            )
            for speaker in proposal.speakers():
                if speaker.email:
                    datamessage_tuple = (
                        self.subject,
                        message_body,
                        self.from_address,
                        [speaker.email],
                    )
                    email_messages.append(datamessage_tuple)
                else:
                    unemailed.append(speaker)
        send_mass_mail(email_messages)
        return unemailed
